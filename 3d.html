<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infiltrados Online 3D</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- NEW: Load Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- NEW: Optional: OrbitControls for camera movement (for testing) -->
    <!-- <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script> -->

    <!-- NEW: Custom styles for Neumorphism (Light) + 3D Background -->
    <style>
        :root {
            /* NEW: Added alpha transparency (c0 = 75%) to the background */
            --neu-bg: #e0e5ecc0; 
            --neu-shadow-light: #ffffff;
            --neu-shadow-dark: #babecc;
        }

        /* NEW: Set a default background for the html element */
        html {
            background-color: #334155; /* slate-700 fallback */
        }
        
        body {
            /* NEW: Body background is transparent to see the canvas */
            background-color: transparent;
        }

        /* NEW: 3D Canvas styles */
        #bg-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* CRITICAL: Sits behind all other content */
            z-index: -1; 
        }

        /* NEW: Frosted glass effect for UI panels */
        .neu-outset, .neu-outset-sm, .neu-inset {
            /* These properties create the "frosted glass" effect
              letting the 3D scene show through blurred.
            */
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        .neu-outset {
            background: var(--neu-bg);
            border-radius: 16px;
            box-shadow: 5px 5px 10px var(--neu-shadow-dark), -5px -5px 10px var(--neu-shadow-light);
        }
        .neu-outset-sm {
            background: var(--neu-bg);
            border-radius: 8px;
            box-shadow: 3px 3px 5px var(--neu-shadow-dark), -3px -3px 5px var(--neu-shadow-light);
        }
        .neu-inset {
            background: var(--neu-bg);
            border-radius: 8px;
            box-shadow: inset 3px 3px 5px var(--neu-shadow-dark), inset -3px -3px 5px var(--neu-shadow-light);
        }
        .neu-input {
            background: transparent;
            border: none;
        }
        .neu-input::placeholder {
            color: #9ca3af; /* text-gray-400 */
        }
        .neu-input:focus {
            outline: none;
        }
        .neu-button {
            background: var(--neu-bg);
            border: none;
            color: #374151; /* text-gray-700 */
            font-weight: 600;
            transition: box-shadow 0.1s ease-in-out;
        }
        .neu-button:active, .neu-button-pressed {
            box-shadow: inset 3px 3px 5px var(--neu-shadow-dark), inset -3px -3px 5px var(--neu-shadow-light) !important;
            color: #4f46e5; /* indigo-600 */
        }
        .neu-button-red { color: #dc2626; /* red-600 */ }
        .neu-button-red:active, .neu-button-red.neu-button-pressed { color: #b91c1c; /* red-700 */ }
        .neu-button-green { color: #16a34a; /* green-600 */ }
        .neu-button-green:active, .neu-button-green.neu-button-pressed { color: #15803d; /* green-700 */ }
        .neu-button-blue { color: #2563eb; /* blue-600 */ }
        .neu-button-blue:active, .neu-button-blue.neu-button-pressed { color: #1d4ed8; /* blue-700 */ }
        .neu-button-gray { color: #6b7280; /* gray-500 */ }
        .neu-button-gray:active, .neu-button-gray.neu-button-pressed { color: #4b5563; /* gray-600 */ }
        
        .neu-select {
            background: var(--neu-bg);
            border: none;
            /* Fix for arrow */
            background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3E%3Cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3E%3C/svg%3E");
            background-position: right 0.5rem center;
            background-repeat: no-repeat;
            background-size: 1.5em 1.5em;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            padding-right: 2.5rem;
        }
    </style>
    <!-- Load Firebase JS SDKs -->
    <script type="module">
        // --- Firebase Imports ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { 
            getAuth, 
            signInAnonymously, 
            onAuthStateChanged,
            signInWithCustomToken
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { 
            getFirestore, 
            doc, 
            setDoc, 
            getDoc, 
            onSnapshot, 
            updateDoc,
            arrayUnion,
            setLogLevel
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- App State ---
        let db, auth, app;
        let currentUserId = null;
        let currentUsername = "Player";
        let currentGameId = null;
        let gameUnsubscribe = null; // To stop listening to game updates
        let localGameData = {}; // Local cache of game state
        let isHost = false;
        let isRoleVisible = false; 
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'infiltrados-game';

        // --- DOM Elements ---
        // NEW: Declare variables here, but assign them inside 'load' listener
        let $, $$;
        let loginSection, lobbySection, gameSection;
        let usernameInput, setUsernameButton, loginError;
        let createGameButton, joinGameButton, gameIdInput, lobbyGameIdDisplay, lobbyPlayerList, startGameButton;
        let totalPlayersSelect, infiltradosSelect, roundsBeforeVoteSelect;
        let customWordContainer, customWordInput, customThemeInput, setCustomWordButton, clearCustomWordButton;
        let gameInfoRole, gameInfoWord, revealRoleButton, gameStatus, gameWordList, gamePlayerList, gameLog;
        let wordInputContainer, wordInput, submitWordButton, gameIdDisplay, gameThemeDisplay;
        let votingModal, votingPlayerButtons, gameOverModal, gameOverWinner, gameOverSecretWord, gameOverInfiltrados;
        let leaveGameButton, playAgainButton;

        // --- Secret Word List ---
        const SECRET_WORDS = [
            "Hospital", "School", "Restaurant", "Airport", "Museum", "Beach",
            "Mountain", "Forest", "Office", "Supermarket", "Pharmacy", "Library",
            "Park", "Zoo", "Aquarium", "Cinema", "Theater", "Gym", "Stadium",
            "Farm", "Factory", "Police Station", "Fire Station", "Post Office"
        ];
        
        const PLAYER_SYMBOLS = ["üëë", "üöÄ", "‚≠ê", "ü§ñ", "ü¶ä", "ü¶Ñ", "üçï", "‚öΩ", "üé®", "üé∏", "üí°", "üìö", "üß≠", "üß™", "üîë", "üõ°Ô∏è"];

        // --- NEW: Three.js State ---
        let scene, camera, renderer, tableMesh, playerFiguresGroup, skyMesh;
        // Simple color array for player figures
        const PLAYER_COLORS = [
            0x_f94144, 0x_f3722c, 0x_f8961e, 0x_f9c74f, 0x_90be6d, 
            0x_6a00f4, 0x_c71fcd
        ];
        const ELIMINATED_COLOR = 0x666666;
        const TURN_COLOR = 0xffffff; // Bright white for the current turn

        // --- Helper function for correct Firestore path ---
        function getGameDocRef(gameId) {
            return doc(db, "artifacts", appId, "public", "data", "games", gameId);
        }

        // --- Firebase Initialization ---
        async function initFirebase() {
            try {
                const firebaseConfig = typeof __firebase_config !== 'undefined'
                    ? JSON.parse(__firebase_config)
                    : {
                        apiKey: "AIzaSyAG6v0TT9miam83wXOB4aqdqD6qbc5GhPo",
                        authDomain: "infiltrados-game.firebaseapp.com",
                        projectId: "infiltrados-game",
                        storageBucket: "infiltrados-game.firebasestorage.app",
                        messagingSenderId: "742547669169",
                        appId: "1:742547669169:web:68ee3277c5fb077647a290"
                    };
                
                if (!firebaseConfig.apiKey) {
                    showError("Firebase config is missing. App cannot start.");
                    return;
                }

                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                setLogLevel('debug'); 

                // --- Auth Handling ---
                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        currentUserId = user.uid;
                        console.log("User signed in:", currentUserId);
                        loginSection.classList.add("hidden");
                        lobbySection.classList.remove("hidden");
                        
                        // NEW: Update 3D scene on auth
                        updateThreeScene(localGameData); 
                    } else {
                        try {
                            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                                await signInWithCustomToken(auth, __initial_auth_token);
                            } else {
                                await signInAnonymously(auth);
                            }
                        } catch (authError) {
                            console.error("Sign-in failed:", authError);
                            showError("Failed to connect. Please refresh.");
                        }
                    }
                });

            } catch (error) {
                console.error("Error initializing Firebase:", error);
                showError("Fatal Error: Could not initialize app. Check console.");
            }
        }

        // --- UI State Management ---
        function showSection(section) {
            [loginSection, lobbySection, gameSection].forEach(s => s.classList.add("hidden"));
            if (section === "login") loginSection.classList.remove("hidden");
            if (section === "lobby") lobbySection.classList.remove("hidden");
            if (section === "game") gameSection.classList.remove("hidden");

            // NEW: Update 3D scene on section change
            if(localGameData) {
                updateThreeScene(localGameData, section);
            }
        }

        function showError(message) {
            console.error("ERROR:", message);
            // Show error in the game status bar if it exists
            if (gameStatus) {
                gameStatus.textContent = `Error: ${message}`;
                gameStatus.classList.add("text-red-600");
            }
        }

        // --- NEW: Three.js Setup ---
        function initThree() {
            const canvas = document.getElementById('bg-canvas');
            
            // 1. Scene
            scene = new THREE.Scene();

            // 2. Camera
            // Mimic the perspective from the guide image
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.5, 5); // Positioned as a player
            camera.rotation.set(-0.2, 0, 0); // Looking slightly down

            // 3. Renderer
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas, 
                antialias: true, 
                alpha: true // Make canvas transparent
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0); // Transparent clear color

            // 4. Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            // 5. Create "Table"
            const tableGeometry = new THREE.PlaneGeometry(20, 15);
            const tableMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x_334155, // slate-700
                shininess: 20
            });
            tableMesh = new THREE.Mesh(tableGeometry, tableMaterial);
            tableMesh.rotation.x = -Math.PI / 2; // Lay it flat
            tableMesh.position.y = 0;
            scene.add(tableMesh);

            // 6. Create Stylized Environment (Low-Poly Mountains)
            const mountainMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x_475569, // slate-600
                flatShading: true 
            });
            const mountainGroup = new THREE.Group();
            for (let i = 0; i < 20; i++) {
                const height = Math.random() * 5 + 2;
                const radius = Math.random() * 1.5 + 0.5;
                const mountainGeom = new THREE.ConeGeometry(radius, height, 6);
                const mountain = new THREE.Mesh(mountainGeom, mountainMaterial);
                
                mountain.position.set(
                    (Math.random() - 0.5) * 40, // Spread them out
                    height / 2, // Base on the "ground" (table)
                    (Math.random() * -15) - 10 // Far distance
                );
                mountainGroup.add(mountain);
            }
            scene.add(mountainGroup);

            // 7. Create Sky
            const skyGeometry = new THREE.PlaneGeometry(100, 100);
            const skyMaterial = new THREE.MeshBasicMaterial({ color: 0x_1e293b }); // slate-800
            skyMesh = new THREE.Mesh(skyGeometry, skyMaterial);
            skyMesh.position.z = -25;
            skyMesh.position.y = 10;
            scene.add(skyMesh);


            // 8. Player Figures Group
            playerFiguresGroup = new THREE.Group();
            playerFiguresGroup.position.y = 0.25; // Sit on the table
            playerFiguresGroup.position.z = -3; // At the "far end"
            scene.add(playerFiguresGroup);

            // 9. Resize Listener
            window.addEventListener('resize', onWindowResize, false);

            // 10. Start Animation Loop
            animate();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // Simple breathing animation for player figures
            if (playerFiguresGroup) {
                playerFiguresGroup.children.forEach((figure, index) => {
                    figure.position.y = 0.25 + Math.sin(Date.now() * 0.002 + index) * 0.05;
                });
            }

            renderer.render(scene, camera);
        }

        /**
         * NEW: Updates the 3D scene based on game data.
         * @param {object} gameData - The localGameData object.
         * @param {string} [section] - The name of the currently visible section ('login', 'lobby', 'game').
         */
        function updateThreeScene(gameData, section) {
            if (!scene || !playerFiguresGroup) return; // Don't run if three.js isn't init

            const currentSection = section || (loginSection.classList.contains('hidden') ? (lobbySection.classList.contains('hidden') ? 'game' : 'lobby') : 'login');

            // Hide figures on login screen
            if (currentSection === 'login' || !gameData.players) {
                playerFiguresGroup.visible = false;
                return;
            }

            playerFiguresGroup.visible = true;

            // Remove old figures
            while (playerFiguresGroup.children.length) {
                playerFiguresGroup.remove(playerFiguresGroup.children[0]);
            }

            const players = Object.values(gameData.players);
            const numPlayers = players.length;
            const angleStep = Math.PI / 8 / (numPlayers - 1 || 1);
            const startAngle = (numPlayers > 1) ? -Math.PI / 16 : 0;
            const radius = 3.5; // Arc radius

            players.forEach((player, index) => {
                const angle = startAngle + (index * angleStep);
                const x = Math.sin(angle) * radius;
                const z = (Math.cos(angle) * radius) - radius; // Pull arc back

                // Create the figure (a simple cylinder 'pawn')
                const geometry = new THREE.CylinderGeometry(0.15, 0.2, 0.5, 12);
                
                let color = PLAYER_COLORS[index % PLAYER_COLORS.length];
                let emissive = 0x000000;

                if (gameData.state !== 'lobby') {
                    // In-game logic
                    if (!player.isAlive) {
                        color = ELIMINATED_COLOR;
                    } else if (gameData.turn === Object.keys(gameData.players)[index]) {
                        // This player's turn
                        color = TURN_COLOR;
                        emissive = 0xeeee00; // Yellow glow
                    } else if (gameData.state === 'voting' && player.vote === null) {
                        // Player has not voted
                        color = PLAYER_COLORS[index % PLAYER_COLORS.length];
                        emissive = 0x0000ff; // Blue glow
                    }
                }
                
                const material = new THREE.MeshPhongMaterial({ 
                    color: color, 
                    emissive: emissive,
                    shininess: 30
                });
                
                const figure = new THREE.Mesh(geometry, material);
                figure.position.set(x, 0, z); // y is 0 relative to the group
                
                // Add a simple "head"
                const headGeom = new THREE.SphereGeometry(0.1, 12, 12);
                const head = new THREE.Mesh(headGeom, material);
                head.position.y = 0.35;
                figure.add(head);

                playerFiguresGroup.add(figure);
            });
        }

        // --- Game Logic (Unchanged from user's code) ---

        function handleUsername() {
            loginError.textContent = "";
            const username = usernameInput.value.trim();
            if (username.length >= 2) {
                currentUsername = username;
                usernameInput.disabled = true;
                setUsernameButton.textContent = "Welcome!";
                setUsernameButton.disabled = true;
                initFirebase();
            } else {
                loginError.textContent = "Please enter a name (min 2 chars).";
            }
        }

        async function createGame() {
            if (!currentUserId) return showError("Not authenticated.");

            const gameId = generateGameId();
            currentGameId = gameId;
            isHost = true;

            const settings = {
                totalPlayers: parseInt(totalPlayersSelect.value),
                infiltradosCount: parseInt(infiltradosSelect.value),
                roundsBeforeVote: parseInt(roundsBeforeVoteSelect.value),
            };

            const gameDoc = {
                gameId: gameId,
                hostId: currentUserId,
                state: "lobby", 
                settings: settings,
                players: {
                    [currentUserId]: {
                        name: currentUsername,
                        isAlive: true,
                        role: null,
                        vote: null,
                        symbol: PLAYER_SYMBOLS[0]
                    }
                },
                secretWord: "",
                customWord: "", 
                customTheme: "", 
                theme: "", 
                turn: null, 
                round: 1, 
                gameTurn: 1, 
                words: [], 
                log: [`Game created by ${currentUsername}`],
                winner: null
            };

            try {
                const gameRef = getGameDocRef(gameId); 
                await setDoc(gameRef, gameDoc);
                console.log("Game created with ID:", gameId);
                await subscribeToGame(gameId);
            } catch (error) {
                console.error("Error creating game:", error);
                showError("Could not create game.");
            }
        }

        async function joinGame() {
            if (!currentUserId) return showError("Not authenticated.");

            const gameId = gameIdInput.value.trim().toUpperCase();
            if (!gameId) return showError("Please enter a Game ID.");

            const gameRef = getGameDocRef(gameId);
            const gameSnap = await getDoc(gameRef);

            if (!gameSnap.exists()) {
                return showError("Game not found.");
            }

            const gameData = gameSnap.data();
            
            if (gameData.state !== "lobby") {
                return showError("Game has already started.");
            }

            if (Object.keys(gameData.players).length >= gameData.settings.totalPlayers) {
                return showError("Game is full.");
            }
            
            if (gameData.players[currentUserId]) {
                console.log("Rejoining lobby...");
            } else {
                const existingSymbols = Object.values(gameData.players).map(p => p.symbol);
                const availableSymbols = PLAYER_SYMBOLS.filter(s => !existingSymbols.includes(s));
                const newSymbol = availableSymbols.length > 0 ? availableSymbols[0] : "‚ùî"; 

                const playerKey = `players.${currentUserId}`;
                const newPlayer = {
                    name: currentUsername,
                    isAlive: true,
                    role: null,
                    vote: null,
                    symbol: newSymbol
                };
                
                try {
                    await updateDoc(gameRef, { 
                        [playerKey]: newPlayer,
                        log: arrayUnion(`${currentUsername} joined the lobby.`)
                    });
                    console.log("Joined game:", gameId);
                } catch (error) {
                    console.error("Error joining game:", error);
                    return showError("Could not join game.");
                }
            }

            currentGameId = gameId;
            isHost = (gameData.hostId === currentUserId);
            await subscribeToGame(gameId);
        }

        async function subscribeToGame(gameId) {
            if (gameUnsubscribe) {
                gameUnsubscribe();
            }
            
            const gameRef = getGameDocRef(gameId);
            gameUnsubscribe = onSnapshot(gameRef, (docSnap) => {
                if (!docSnap.exists()) {
                    showError("Game not found or was deleted.");
                    leaveGame();
                    return;
                }

                const gameData = docSnap.data();
                localGameData = gameData; // Cache game data
                updateUI(gameData);

                // --- Host-Only Logic ---
                if (isHost) {
                    if (gameData.state === "voting" && didAllAlivePlayersVote(gameData)) {
                        tallyVotes(gameData);
                    }
                    if (gameData.state === "word_round" && shouldRoundEnd(gameData)) {
                        startVoting(gameData);
                    }
                }

            }, (error) => {
                console.error("Snapshot error:", error);
                showError("Connection to game lost.");
            });
        }

        function leaveGame() {
            if (gameUnsubscribe) {
                gameUnsubscribe();
                gameUnsubscribe = null;
            }
            currentGameId = null;
            isHost = false;
            localGameData = {};
            isRoleVisible = false; 
            showSection("lobby");
            lobbyGameIdDisplay.textContent = "";
            lobbyPlayerList.innerHTML = "";
            gameIdInput.value = "";
            customWordContainer.classList.add("hidden"); 
            
            // NEW: Update 3D scene
            updateThreeScene({});
        }

        async function startGame() {
            if (!isHost || !currentGameId) return;

            const gameData = localGameData;
            const playerIds = Object.keys(gameData.players);

            const isDebugMode = (currentUsername === "debug" || currentUsername === "admin");

            if (playerIds.length !== gameData.settings.totalPlayers && !isDebugMode) { 
                return showError(`Waiting for ${gameData.settings.totalPlayers} players. Currently have ${playerIds.length}.`);
            }

            if (isDebugMode && playerIds.length < gameData.settings.totalPlayers) {
                console.warn("DEBUG MODE: Starting game with fewer players than setting.");
                gameData.settings.totalPlayers = playerIds.length;
                
                if (gameData.settings.infiltradosCount >= playerIds.length) {
                    gameData.settings.infiltradosCount = 1; 
                    console.warn("DEBUG MODE: Infiltrado count adjusted to 1.");
                }
            }
            
            // --- Assign Roles ---
            const { infiltradosCount } = gameData.settings;
            const newPlayers = { ...gameData.players };
            const shuffledPlayerIds = playerIds.sort(() => 0.5 - Math.random());
            
            const infiltradoIds = [];
            
            for (let i = 0; i < shuffledPlayerIds.length; i++) {
                const id = shuffledPlayerIds[i];
                if (i < infiltradosCount) {
                    newPlayers[id].role = "Infiltrado";
                    infiltradoIds.push(newPlayers[id].name); 
                } else {
                    newPlayers[id].role = "Regular";
                }
            }

            // --- Pick Word & Start Player ---
            const customWord = gameData.customWord;
            const customTheme = gameData.customTheme;
            
            const secretWord = customWord || SECRET_WORDS[Math.floor(Math.random() * SECRET_WORDS.length)];
            const theme = customWord ? (customTheme || "General") : "Location/Place"; 
            
            const regularPlayerIds = Object.keys(newPlayers).filter(id => newPlayers[id].role === "Regular");
            
            let startPlayerId;
            if (regularPlayerIds.length > 0) {
                startPlayerId = regularPlayerIds[Math.floor(Math.random() * regularPlayerIds.length)];
            } else {
                console.warn("No regular players found! Starting with a random player.");
                startPlayerId = shuffledPlayerIds[Math.floor(Math.random() * shuffledPlayerIds.length)];
            }

            // --- Update Game Doc ---
            try {
                const gameRef = getGameDocRef(currentGameId);
                await updateDoc(gameRef, {
                    state: "word_round",
                    players: newPlayers,
                    secretWord: secretWord,
                    theme: theme, 
                    customWord: "", 
                    customTheme: "", 
                    turn: startPlayerId,
                    round: 1,
                    gameTurn: 1,
                    words: [],
                    log: arrayUnion(`Game started! Theme: ${theme}. Roles assigned.`)
                });
            } catch (error) {
                console.error("Error starting game:", error);
                showError("Could not start game.");
            }
        }
        
        async function submitWord() {
            const word = wordInput.value.trim();
            if (word.length < 2 || word.includes(" ")) {
                return showError("Please enter a single, valid word.");
            }
            
            if (localGameData.turn !== currentUserId) {
                return showError("It's not your turn!");
            }

            const { players, round, settings, gameTurn } = localGameData;
            const totalAlive = Object.values(players).filter(p => p.isAlive).length;
            const wordsThisRound = localGameData.words.filter(w => w.gameTurn === gameTurn && w.round === round).length;

            const nextPlayer = findNextAlivePlayer(currentUserId);
            let nextRound = round;
            let nextState = "word_round";
            let nextTurn = nextPlayer;
            
            if (wordsThisRound + 1 === totalAlive) {
                nextRound = round + 1;
                nextTurn = findNextAlivePlayer(nextPlayer, true, localGameData.turn); 
            }

            try {
                const gameRef = getGameDocRef(currentGameId); 
                await updateDoc(gameRef, {
                    state: nextState,
                    turn: nextTurn,
                    round: nextRound,
                    words: arrayUnion({
                        player: currentUserId,
                        name: players[currentUserId].name,
                        word: word,
                        round: round,
                        gameTurn: gameTurn
                    })
                });
                wordInput.value = "";
            } catch (error) {
                console.error("Error submitting word:", error);
                showError("Could not submit word.");
            }
        }
        
        function shouldRoundEnd(gameData) {
            const { players, round, settings, gameTurn, words } = gameData;
            
            if (round > 1 && (round - 1) % settings.roundsBeforeVote === 0) {
                const totalAlive = Object.values(players).filter(p => p.isAlive).length;
                const wordsInLastRound = words.filter(w => w.gameTurn === gameTurn && w.round === (round - 1)).length;
                
                if (wordsInLastRound === totalAlive) {
                    return true;
                }
            }
            return false;
        }

        async function startVoting(gameData) {
            const playerUpdates = {};
            Object.keys(gameData.players).forEach(id => {
                if (gameData.players[id].isAlive) {
                    playerUpdates[`players.${id}.vote`] = null;
                }
            });
            
            try {
                const gameRef = getGameDocRef(currentGameId); 
                await updateDoc(gameRef, {
                    ...playerUpdates,
                    state: "voting",
                    turn: null, 
                    log: arrayUnion(`--- Time to Vote (Turn ${gameData.gameTurn}) ---`)
                });
            } catch (error) {
                console.error("Error starting vote:", error);
            }
        }

        async function submitVote(votedPlayerId) {
            if (localGameData.state !== "voting" || !localGameData.players[currentUserId].isAlive) {
                return showError("You can't vote right now.");
            }
            
            votingModal.classList.add("hidden");
            
            try {
                const gameRef = getGameDocRef(currentGameId); 
                await updateDoc(gameRef, {
                    [`players.${currentUserId}.vote`]: votedPlayerId
                });
            } catch (error) {
                console.error("Error submitting vote:", error);
            }
        }

        function didAllAlivePlayersVote(gameData) {
            return Object.values(gameData.players).every(p => !p.isAlive || p.vote !== null);
        }

        async function tallyVotes(gameData) {
            const votes = {};
            let tiedPlayers = [];
            let maxVotes = 0;
            
            Object.values(gameData.players).forEach(p => {
                if (p.isAlive && p.vote) {
                    votes[p.vote] = (votes[p.vote] || 0) + 1;
                }
            });

            for (const playerId in votes) {
                if (votes[playerId] > maxVotes) {
                    maxVotes = votes[playerId];
                }
            }

            for (const playerId in votes) {
                if (votes[playerId] === maxVotes) {
                    tiedPlayers.push(playerId);
                }
            }
            
            let eliminatedPlayerId;
            let logMessage;

            if (tiedPlayers.length === 0) {
                console.warn("No votes cast? Defaulting to random elim.");
                const alivePlayers = Object.keys(gameData.players).filter(id => gameData.players[id].isAlive);
                eliminatedPlayerId = alivePlayers[Math.floor(Math.random() * alivePlayers.length)];
                logMessage = "No votes were cast! By random choice,";
                
            } else if (tiedPlayers.length === 1) {
                eliminatedPlayerId = tiedPlayers[0];
                logMessage = "The votes are in!";
            } else {
                eliminatedPlayerId = tiedPlayers[Math.floor(Math.random() * tiedPlayers.length)];
                logMessage = `A tie! By random choice,`;
            }

            const eliminatedPlayer = gameData.players[eliminatedPlayerId];
            logMessage += ` ${eliminatedPlayer.name} is eliminated.`;
            const revealMessage = `${eliminatedPlayer.name} was... an ${eliminatedPlayer.role}!`;

            // --- Check Win Conditions ---
            const finalPlayerCounts = { ...gameData.players };
            finalPlayerCounts[eliminatedPlayerId].isAlive = false;
            
            let finalRegulars = 0;
            let finalInfiltrados = 0;
            Object.values(finalPlayerCounts).forEach(p => {
                if (p.isAlive) {
                    if (p.role === "Regular") finalRegulars++;
                    if (p.role === "Infiltrado") finalInfiltrados++;
                }
            });
            
            let nextState = "word_round";
            let winner = null;
            
            if (finalInfiltrados === 0) {
                nextState = "game_over";
                winner = "Regulars";
                logMessage = "The last Infiltrado is out!";
            } else if (finalInfiltrados >= finalRegulars) {
                nextState = "game_over";
                winner = "Infiltrados";
                logMessage = "The Infiltrados can no longer be outvoted!";
            }

            const nextTurnPlayer = findNextAlivePlayer(eliminatedPlayerId, false, gameData.turn);

            try {
                const gameRef = getGameDocRef(currentGameId); 
                await updateDoc(gameRef, {
                    [`players.${eliminatedPlayerId}.isAlive`]: false,
                    state: nextState,
                    winner: winner,
                    turn: nextTurnPlayer,
                    gameTurn: gameData.gameTurn + 1,
                    log: arrayUnion(logMessage, revealMessage)
                });

            } catch (error) {
                console.error("Error in tallyVotes:", error);
            }
        }
        
        async function playAgain() {
            if (!isHost) return;
            
            const newPlayers = { ...localGameData.players };
            Object.keys(newPlayers).forEach(id => {
                newPlayers[id].isAlive = true;
                newPlayers[id].role = null;
                newPlayers[id].vote = null;
            });
            
            try {
                const gameRef = getGameDocRef(currentGameId); 
                await updateDoc(gameRef, {
                    state: "lobby",
                    players: newPlayers,
                    secretWord: "",
                    customWord: "", 
                    customTheme: "", 
                    theme: "", 
                    turn: null,
                    round: 1,
                    gameTurn: 1,
                    words: [],
                    log: ["Host started a new game!"],
                    winner: null
                });
            } catch(error) {
                console.error("Error playing again:", error);
            }
        }

        function updateRoleVisibility() {
            if (isRoleVisible) {
                const myPlayerData = localGameData.players[currentUserId];
                if (!myPlayerData) return;

                gameInfoRole.textContent = `Role: ${myPlayerData.role}`;
                gameInfoRole.className = myPlayerData.role === "Infiltrado" ? "text-lg font-bold text-red-600" : "text-lg font-bold text-green-600";
                
                if (myPlayerData.role === "Regular") {
                    gameInfoWord.textContent = `Word: ${localGameData.secretWord}`;
                } else if (myPlayerData.role === "Infiltrado") {
                    gameInfoWord.textContent = "Blend in! Guess the word.";
                }
                gameInfoWord.classList.remove("hidden");
                revealRoleButton.textContent = "Hide Role";
                revealRoleButton.classList.add("neu-button-pressed");
            } else {
                gameInfoRole.textContent = "Your Role: [Hidden]";
                gameInfoRole.className = "text-lg font-bold text-gray-700";
                gameInfoWord.classList.add("hidden");
                revealRoleButton.textContent = "Show Role";
                revealRoleButton.classList.remove("neu-button-pressed");
            }
        }

        // --- UI Update Function ---
        function updateUI(gameData) {
            // NEW: Update 3D scene first
            updateThreeScene(gameData);

            // --- Get player data (needed for modals) ---
            const myPlayerData = gameData.players[currentUserId];
            const amIAlive = myPlayerData && myPlayerData.isAlive;

            // --- Lobby Section ---
            if (gameData.state === "lobby") {
                isRoleVisible = false; 
                showSection("lobby");
                lobbyGameIdDisplay.textContent = `Game ID: ${gameData.gameId}`;
                
                const players = Object.values(gameData.players);
                lobbyPlayerList.innerHTML = players.map(p => 
                    `<li class="neu-outset-sm p-2">${p.symbol} ${p.name}</li>`
                ).join("");
                
                // Host controls
                startGameButton.classList.toggle("hidden", !isHost);
                $$(".host-setting").forEach(el => el.disabled = !isHost);
                if (isHost) {
                    totalPlayersSelect.value = gameData.settings.totalPlayers;
                    infiltradosSelect.value = gameData.settings.infiltradosCount;
                    roundsBeforeVoteSelect.value = gameData.settings.roundsBeforeVote;
                    customWordContainer.classList.remove("hidden");
                    customWordInput.value = gameData.customWord || "";
                    customThemeInput.value = gameData.customTheme || ""; 
                } else {
                    customWordContainer.classList.add("hidden");
                }
            }
            
            // --- Game Section ---
            if (gameData.state !== "lobby") {
                showSection("game");
                customWordContainer.classList.add("hidden");
                
                gameIdDisplay.textContent = `Game ID: ${gameData.gameId}`;
                gameThemeDisplay.textContent = `Theme: ${gameData.theme || "Loading..."}`; 

                revealRoleButton.classList.toggle("hidden", !myPlayerData);
                updateRoleVisibility(); 

                // Game Status
                let statusText = "";
                if (gameData.state === "word_round") {
                    const turnPlayerName = gameData.players[gameData.turn]?.name || "Someone";
                    statusText = `Round ${gameData.round}: Waiting for ${turnPlayerName} to speak.`;
                } else if (gameData.state === "voting") {
                    statusText = `Time to vote! (Turn ${gameData.gameTurn})`;
                } else if (gameData.state === "game_over") {
                    statusText = `Game Over! ${gameData.winner} win!`;
                }
                gameStatus.textContent = statusText;

                // Word Input
                const isMyTurn = gameData.state === "word_round" && gameData.turn === currentUserId;
                wordInputContainer.classList.toggle("hidden", !isMyTurn || !amIAlive);

                // Word List
                gameWordList.innerHTML = gameData.words.map(w => {
                    const playerSymbol = gameData.players[w.player]?.symbol || "‚ùî";
                    return `<li class="neu-outset-sm p-2">
                        <span class="font-bold text-indigo-600">${playerSymbol} ${w.name} (R${w.round}):</span>
                        <span class="ml-2 text-gray-800">${w.word}</span>
                    </li>`
                }).join("");
                gameWordList.scrollTop = gameWordList.scrollHeight;
                
                // Player List
                gamePlayerList.innerHTML = Object.values(gameData.players).map(p => 
                    `<li class="p-2 rounded-lg ${p.isAlive ? 'neu-outset-sm' : 'neu-inset text-gray-500 line-through'}">
                        ${p.symbol} ${p.name}
                        ${p.isAlive ? '' : ' (Eliminated)'}
                    </li>`
                ).join("");
                
                // Game Log
                gameLog.innerHTML = gameData.log.slice().reverse().map(entry => 
                    `<li class="text-xs text-gray-600">${entry}</li>`
                ).join("");
            }
            
            // Voting Modal
            if (gameData.state === "voting" && amIAlive && myPlayerData.vote === null) {
                votingPlayerButtons.innerHTML = Object.keys(gameData.players)
                    .filter(id => gameData.players[id].isAlive) 
                    .map(id => {
                        const player = gameData.players[id];
                        const isMe = id === currentUserId;
                        const playerSymbol = player.symbol || "‚ùî"; 
                        return `<button data-vote-id="${id}" class="vote-button w-full p-3 rounded-lg neu-button neu-outset ${isMe ? 'neu-button-gray opacity-50 cursor-not-allowed' : 'neu-button-red'}">
                            Vote ${playerSymbol} ${player.name} ${isMe ? '(You)' : ''}
                        </button>`;
                    }).join("");
                votingModal.classList.remove("hidden");
            } else {
                votingModal.classList.add("hidden");
            }
            
            // Game Over Modal
            if (gameData.state === "game_over") {
                isRoleVisible = false; 
                gameOverWinner.textContent = `${gameData.winner} Win!`;
                gameOverSecretWord.textContent = `Word: ${gameData.secretWord} (Theme: ${gameData.theme})`;
                
                const infiltradoNames = Object.values(gameData.players)
                    .filter(p => p.role === "Infiltrado")
                    .map(p => `${p.symbol} ${p.name}`) 
                    .join(", ");
                gameOverInfiltrados.textContent = `Infiltrados: ${infiltradoNames}`;
                
                playAgainButton.classList.toggle("hidden", !isHost);
                gameOverModal.classList.remove("hidden");
            } else {
                gameOverModal.classList.add("hidden");
            }
        }
        
        // --- Helper Functions ---
        
        function generateGameId() {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }

        function findNextAlivePlayer(startPlayerId, forceSameRound = false, roundStartPlayerId = null) {
            const playerIds = Object.keys(localGameData.players);
            const alivePlayerIds = playerIds.filter(id => localGameData.players[id].isAlive);
            
            alivePlayerIds.sort();
            
            if (forceSameRound && roundStartPlayerId) {
                const roundStartIndex = alivePlayerIds.indexOf(roundStartPlayerId);
                if (roundStartIndex !== -1) {
                    return alivePlayerIds[roundStartIndex];
                }
            }

            const startIndex = alivePlayerIds.indexOf(startPlayerId);
            
            if (startIndex === -1) {
                return alivePlayerIds[0] || null;
            }
            
            const nextIndex = (startIndex + 1) % alivePlayerIds.length;
            return alivePlayerIds[nextIndex];
        }

        // --- Event Listeners ---
        window.addEventListener("load", () => {
            // NEW: Assign all DOM elements now that the page is loaded
            $ = (selector) => document.querySelector(selector);
            $$ = (selector) => document.querySelectorAll(selector);

            // Page Sections
            loginSection = $("#login-section");
            lobbySection = $("#lobby-section");
            gameSection = $("#game-section");
            
            // Login
            usernameInput = $("#username-input");
            setUsernameButton = $("#set-username-button");
            loginError = $("#login-error");

            // Lobby
            createGameButton = $("#create-game-button");
            joinGameButton = $("#join-game-button");
            gameIdInput = $("#game-id-input");
            lobbyGameIdDisplay = $("#lobby-game-id");
            lobbyPlayerList = $("#lobby-player-list");
            startGameButton = $("#start-game-button");

            // Game Settings (Lobby)
            totalPlayersSelect = $("#total-players-select");
            infiltradosSelect = $("#infiltrados-select");
            roundsBeforeVoteSelect = $("#rounds-before-vote-select");
            customWordContainer = $("#custom-word-container");
            customWordInput = $("#custom-word-input");
            customThemeInput = $("#custom-theme-input"); 
            setCustomWordButton = $("#set-custom-word-button");
            clearCustomWordButton = $("#clear-custom-word-button");
            
            // Game
            gameInfoRole = $("#game-info-role");
            gameInfoWord = $("#game-info-word");
            revealRoleButton = $("#reveal-role-button");
            gameStatus = $("#game-status");
            gameWordList = $("#game-word-list");
            gamePlayerList = $("#game-player-list");
            gameLog = $("#game-log");
            wordInputContainer = $("#word-input-container");
            wordInput = $("#word-input");
            submitWordButton = $("#submit-word-button");
            gameIdDisplay = $("#game-id-display");
            gameThemeDisplay = $("#game-theme-display"); 

            // Modals
            votingModal = $("#voting-modal");
            votingPlayerButtons = $("#voting-player-buttons");
            gameOverModal = $("#game-over-modal");
            gameOverWinner = $("#game-over-winner");
            gameOverSecretWord = $("#game-over-secret-word");
            gameOverInfiltrados = $("#game-over-infiltrados");
            leaveGameButton = $("#leave-game-button");
            playAgainButton = $("#play-again-button");

            // --- End of NEW DOM Assignments ---

            // NEW: Init Three.js first
            initThree();

            showSection("login");
            
            setUsernameButton.addEventListener("click", handleUsername);
            usernameInput.addEventListener("keydown", (e) => {
                if (e.key === "Enter") handleUsername();
            });

            createGameButton.addEventListener("click", createGame);
            joinGameButton.addEventListener("click", joinGame);
            startGameButton.addEventListener("click", startGame);

            submitWordButton.addEventListener("click", submitWord);
            wordInput.addEventListener("keydown", (e) => {
                if (e.key === "Enter") submitWord();
            });
            
            votingPlayerButtons.addEventListener("click", (e) => {
                const button = e.target.closest(".vote-button");
                if (button && button.dataset.voteId) {
                    if (button.dataset.voteId === currentUserId) return; 
                    submitVote(button.dataset.voteId);
                }
            });
            
            leaveGameButton.addEventListener("click", leaveGame);
            playAgainButton.addEventListener("click", playAgain);

            setCustomWordButton.addEventListener("click", async () => {
                if (!isHost || !currentGameId || localGameData.state !== 'lobby') return;
                const word = customWordInput.value.trim();
                const theme = customThemeInput.value.trim(); 
                if (word.length < 2 || word.includes(" ")) {
                    showError("Custom word must be a single word, min 2 chars.");
                    return;
                }
                try {
                    const gameRef = getGameDocRef(currentGameId);
                    await updateDoc(gameRef, { customWord: word, customTheme: theme }); 
                    localGameData.customWord = word; 
                    localGameData.customTheme = theme; 
                } catch (error) {
                    console.error("Error setting custom word:", error);
                }
            });
            
            clearCustomWordButton.addEventListener("click", async () => {
                if (!isHost || !currentGameId || localGameData.state !== 'lobby') return;
                try {
                    const gameRef = getGameDocRef(currentGameId);
                    await updateDoc(gameRef, { customWord: "", customTheme: "" }); 
                    localGameData.customWord = ""; 
                    localGameData.customTheme = ""; 
                    customWordInput.value = "";
                    customThemeInput.value = ""; 
                } catch (error) {
                    console.error("Error clearing custom word:", error);
                }
            });
            
            revealRoleButton.addEventListener("click", () => {
                isRoleVisible = !isRoleVisible; 
                updateRoleVisibility(); 
            });

            $$(".host-setting").forEach(el => {
                el.addEventListener("change", async (e) => {
                    if (isHost && currentGameId && localGameData.state === 'lobby') {
                        const key = e.target.dataset.setting;
                        const value = parseInt(e.target.value);
                        try {
                            const gameRef = getGameDocRef(currentGameId); 
                            await updateDoc(gameRef, {
                                [`settings.${key}`]: value
                            });
                        } catch (error) {
                            console.error("Error updating setting:", error);
                        }
                    }
                });
            });
        });

    </script>
</head>
<body class="h-full font-sans text-gray-700">

    <!-- NEW: 3D Background Canvas -->
    <canvas id="bg-canvas"></canvas>

    <!-- Login Section -->
    <section id="login-section" class="flex items-center justify-center h-full p-4">
        <div class="neu-outset p-8 rounded-2xl w-full max-w-sm">
            <h1 class="text-3xl font-bold text-gray-800 text-center mb-6">Welcome to Infiltrados</h1>
            <div class="space-y-4">
                <label for="username-input" class="block text-sm font-medium text-gray-600">Enter your name:</label>
                <input type="text" id="username-input" class="w-full p-3 neu-inset neu-input" placeholder="e.g., Player1">
                <button id="set-username-button" class="w-full p-3 rounded-lg neu-button neu-outset text-indigo-600">
                    Join
                </button>
                <p id="login-error" class="text-red-600 text-sm text-center h-4"></p>
            </div>
        </div>
    </section>

    <!-- Lobby Section -->
    <section id="lobby-section" class="hidden h-full p-4 md:p-8 overflow-y-auto">
        <div class="max-w-4xl mx-auto">
            <h1 class="text-3xl font-bold text-gray-800 text-center mb-6">Game Lobby</h1>
            
            <!-- Join/Create -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                <!-- Create Game -->
                <div class="neu-outset p-6 rounded-2xl">
                    <h2 class="text-xl font-semibold text-gray-800 mb-4">Create New Game</h2>
                    <!-- Settings -->
                    <div class="space-y-3 mb-4">
                        <div>
                            <label for="total-players-select" class="block text-sm font-medium text-gray-600">Total Players</label>
                            <select id="total-players-select" data-setting="totalPlayers" class="host-setting w-full p-2 neu-inset neu-select mt-1">
                                <option>3</option>
                                <option>4</option>
                                <option>5</option>
                                <option>6</option>
                                <option>7</option>
                                <option selected>8</option>
                                <option>9</option>
                                <option>10</option>
                            </select>
                        </div>
                        <div>
                            <label for="infiltrados-select" class="block text-sm font-medium text-gray-600">Infiltrados</label>
                            <select id="infiltrados-select" data-setting="infiltradosCount" class="host-setting w-full p-2 neu-inset neu-select mt-1">
                                <option>1</option>
                                <option selected>2</option>
                                <option>3</option>
                            </select>
                        </div>
                        <div>
                            <label for="rounds-before-vote-select" class="block text-sm font-medium text-gray-600">Rounds Before Vote</label>
                            <select id="rounds-before-vote-select" data-setting="roundsBeforeVote" class="host-setting w-full p-2 neu-inset neu-select mt-1">
                                <option>1</option>
                                <option selected>2</option>
                                <option>3</option>
                            </select>
                        </div>
                    </div>
                    <button id="create-game-button" class="w-full p-3 rounded-lg neu-button neu-outset text-indigo-600">
                        Create Game
                    </button>
                </div>
                
                <!-- Join Game -->
                <div class="neu-outset p-6 rounded-2xl">
                    <h2 class="text-xl font-semibold text-gray-800 mb-4">Join Game</h2>
                    <label for="game-id-input" class="block text-sm font-medium text-gray-600">Enter Game ID:</label>
                    <input type="text" id="game-id-input" class="w-full p-3 mt-1 neu-inset neu-input uppercase" placeholder="ABCXYZ">
                    <button id="join-game-button" class="w-full p-3 mt-4 rounded-lg neu-button neu-outset neu-button-green">
                        Join Game
                    </button>
                </div>
            </div>
            
            <!-- Current Lobby -->
            <div class="neu-outset p-6 rounded-2xl">
                <h2 class="text-2xl font-semibold text-gray-800 mb-4">Waiting Room</h2>
                <h3 id="lobby-game-id" class="text-xl text-indigo-500 font-mono mb-4"></h3>

                <!-- Custom Word Input (Host Only) -->
                <div id="custom-word-container" class="hidden mb-4 p-4 neu-inset rounded-lg space-y-2">
                    <div>
                        <label for="custom-word-input" class="block text-sm font-medium text-gray-600">Custom Secret Word (Host Only)</label>
                        <input type="text" id="custom-word-input" class="w-full p-2 neu-inset neu-input" placeholder="Leave blank for random">
                    </div>
                    <div>
                        <label for="custom-theme-input" class="block text-sm font-medium text-gray-600">Theme (Optional)</label>
                        <input type="text" id="custom-theme-input" class="w-full p-2 neu-inset neu-input" placeholder="e.g., Football Players">
                    </div>
                    <div class="flex gap-2 pt-2">
                        <button id="set-custom-word-button" class="p-2 neu-button neu-outset-sm rounded-lg neu-button-green">Set</button>
                        <button id="clear-custom-word-button" class="p-2 neu-button neu-outset-sm rounded-lg neu-button-gray">Clear</button>
                    </div>
                </div>

                <h4 class="text-lg text-gray-800 mb-2">Players:</h4>
                <ul id="lobby-player-list" class="space-y-2 mb-4">
                    <!-- Player list injected by JS -->
                </ul>
                <button id="start-game-button" class="w-full p-3 rounded-lg neu-button neu-outset neu-button-red hidden">
                    Start Game (Host Only)
                </button>
            </div>
            
        </div>
    </section>

    <!-- Game Section -->
    <section id="game-section" class="hidden h-full flex flex-col p-4 md:p-8">
        <div class="flex-shrink-0 mb-4">
            <!-- Top Bar -->
            <div class="neu-outset flex flex-wrap justify-between items-center p-4 rounded-2xl gap-4">
                <div>
                    <h1 class="text-2xl font-bold text-gray-800">Infiltrados</h1>
                    <div id="game-id-display" class="text-sm font-mono text-indigo-500"></div>
                    <div id="game-theme-display" class="text-md font-semibold text-gray-700"></div> 
                </div>
                <div class="text-right">
                    <div id="game-info-role" class="text-lg font-bold text-gray-700">Your Role: [Hidden]</div>
                    <div id="game-info-word" class="text-sm text-gray-600 hidden"></div>
                    <button id="reveal-role-button" class="mt-1 p-2 neu-button neu-outset-sm rounded-lg text-sm neu-button-blue">
                        Show Role
                    </button>
                </div>
                <button id="leave-game-button" class="p-2 neu-button neu-outset-sm rounded-lg text-sm neu-button-gray self-start">Leave Game</button>
            </div>
            <!-- Status Bar -->
            <div id="game-status" class="text-center text-xl font-semibold text-yellow-600 p-4">
                Loading game...
            </div>
        </div>

        <!-- Main Game Area -->
        <div class="flex-grow grid grid-cols-1 lg:grid-cols-4 gap-6 min-h-0">
            
            <!-- Players -->
            <div class="neu-outset p-4 rounded-2xl overflow-y-auto">
                <h3 class="text-lg font-semibold text-gray-800 mb-3 border-b border-gray-300 pb-2">Players</h3>
                <ul id="game-player-list" class="space-y-2">
                    <!-- Player list injected by JS -->
                </ul>
            </div>
            
            <!-- Words -->
            <div class="neu-outset p-4 rounded-2xl lg:col-span-2 flex flex-col">
                <h3 class="text-lg font-semibold text-gray-800 mb-3 border-b border-gray-300 pb-2">Word List</h3>
                <ul id="game-word-list" class="flex-grow space-y-2 overflow-y-auto h-64 md:h-auto p-1">
                    <!-- Word list injected by JS -->
                </ul>
                <!-- Word Input -->
                <div id="word-input-container" class="mt-4 flex gap-2 hidden">
                    <input type="text" id="word-input" class="flex-grow p-3 neu-inset neu-input" placeholder="Your word...">
                    <button id="submit-word-button" class="p-3 rounded-lg neu-button neu-outset text-indigo-600">
                        Submit
                    </button>
                </div>
            </div>
            
            <!-- Log -->
            <div class="neu-outset p-4 rounded-2xl overflow-y-auto">
                <h3 class="text-lg font-semibold text-gray-800 mb-3 border-b border-gray-300 pb-2">Game Log</h3>
                <ul id="game-log" class="space-y-1 h-64 md:h-auto max-h-72"> 
                    <!-- Log entries injected by JS -->
                </ul>
            </div>
            
        </div>
    </section>
    
    <!-- Voting Modal -->
    <div id="voting-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
        <div class="neu-outset p-8 rounded-2xl shadow-xl w-full max-w-md">
            <h2 class="text-3xl font-bold text-gray-800 text-center mb-6">Vote to Eliminate!</h2>
            <div id="voting-player-buttons" class="space-y-3">
                <!-- Voting buttons injected by JS -->
            </div>
        </div>
    </div>
    
    <!-- Game Over Modal -->
    <div id="game-over-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
        <div class="neu-outset p-8 rounded-2xl shadow-xl w-full max-w-md text-center">
            <h2 id="game-over-winner" class="text-4xl font-bold text-yellow-600 mb-4"></h2>
            <p id="game-over-secret-word" class="text-xl text-gray-800 mb-2"></p>
            <p id="game-over-infiltrados" class="text-lg text-red-600 mb-8"></p>
            
            <button id="play-again-button" class="w-full p-3 mb-3 rounded-lg neu-button neu-outset text-indigo-600 hidden">
                Play Again (Host)
            </button>
            <p class="text-sm text-gray-600">Wait for the host to start a new game.</p>
        </div>
    </div>

</body>
</html>
