<!DOCTYPE html>
<html lang="en" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infiltrados Online</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- NEW: Custom styles for Neumorphism (Light) -->
    <style>
        :root {
            --neu-bg: #e0e5ec;
            --neu-shadow-light: #ffffff;
            --neu-shadow-dark: #babecc;
        }
        body {
            background-color: var(--neu-bg);
        }
        .neu-outset {
            background: var(--neu-bg);
            border-radius: 16px;
            box-shadow: 5px 5px 10px var(--neu-shadow-dark), -5px -5px 10px var(--neu-shadow-light);
        }
        .neu-outset-sm {
            background: var(--neu-bg);
            border-radius: 8px;
            box-shadow: 3px 3px 5px var(--neu-shadow-dark), -3px -3px 5px var(--neu-shadow-light);
        }
        .neu-inset {
            background: var(--neu-bg);
            border-radius: 8px;
            box-shadow: inset 3px 3px 5px var(--neu-shadow-dark), inset -3px -3px 5px var(--neu-shadow-light);
        }
        .neu-input {
            background: transparent;
            border: none;
        }
        .neu-input::placeholder {
            color: #9ca3af; /* text-gray-400 */
        }
        .neu-input:focus {
            outline: none;
        }
        .neu-button {
            background: var(--neu-bg);
            border: none;
            color: #374151; /* text-gray-700 */
            font-weight: 600;
            transition: box-shadow 0.1s ease-in-out;
        }
        .neu-button:active, .neu-button-pressed {
            box-shadow: inset 3px 3px 5px var(--neu-shadow-dark), inset -3px -3px 5px var(--neu-shadow-light) !important;
            color: #4f46e5; /* indigo-600 */
        }
        .neu-button-red { color: #dc2626; /* red-600 */ }
        .neu-button-red:active, .neu-button-red.neu-button-pressed { color: #b91c1c; /* red-700 */ }
        .neu-button-green { color: #16a34a; /* green-600 */ }
        .neu-button-green:active, .neu-button-green.neu-button-pressed { color: #15803d; /* green-700 */ }
        .neu-button-blue { color: #2563eb; /* blue-600 */ }
        .neu-button-blue:active, .neu-button-blue.neu-button-pressed { color: #1d4ed8; /* blue-700 */ }
        .neu-button-gray { color: #6b7280; /* gray-500 */ }
        .neu-button-gray:active, .neu-button-gray.neu-button-pressed { color: #4b5563; /* gray-600 */ }
        
        .neu-select {
            background: var(--neu-bg);
            border: none;
            /* Fix for arrow */
            background-image: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3E%3Cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3E%3C/svg%3E");
            background-position: right 0.5rem center;
            background-repeat: no-repeat;
            background-size: 1.5em 1.5em;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            padding-right: 2.5rem;
        }
    </style>
    <!-- Load Firebase JS SDKs -->
    <script type="module">
        // --- Firebase Imports ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { 
            getAuth, 
            signInAnonymously, 
            onAuthStateChanged,
            signInWithCustomToken
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { 
            getFirestore, 
            doc, 
            setDoc, 
            getDoc, 
            onSnapshot, 
            updateDoc,
            arrayUnion,
            setLogLevel
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- App State ---
        let db, auth, app;
        let currentUserId = null;
        let currentUsername = "Player";
        let currentGameId = null;
        let gameUnsubscribe = null; // To stop listening to game updates
        let localGameData = {}; // Local cache of game state
        let isHost = false;
        let isRoleVisible = false; // NEW: State for role visibility
        // Moved appId to module scope so all functions can access it
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'infiltrados-game';

        // --- DOM Elements ---
        const $ = (selector) => document.querySelector(selector);
        const $$ = (selector) => document.querySelectorAll(selector);

        // Page Sections
        const loginSection = $("#login-section");
        const lobbySection = $("#lobby-section");
        const gameSection = $("#game-section");
        
        // Login
        const usernameInput = $("#username-input");
        const setUsernameButton = $("#set-username-button");
        const loginError = $("#login-error");

        // Lobby
        const createGameButton = $("#create-game-button");
        const joinGameButton = $("#join-game-button");
        const gameIdInput = $("#game-id-input");
        const lobbyGameIdDisplay = $("#lobby-game-id");
        const lobbyPlayerList = $("#lobby-player-list");
        const startGameButton = $("#start-game-button");

        // Game Settings (Lobby)
        const totalPlayersSelect = $("#total-players-select");
        const infiltradosSelect = $("#infiltrados-select");
        const roundsBeforeVoteSelect = $("#rounds-before-vote-select");
        // NEW: Custom Word Elements
        const customWordContainer = $("#custom-word-container");
        const customWordInput = $("#custom-word-input");
        const customThemeInput = $("#custom-theme-input"); // NEW: Theme input
        const setCustomWordButton = $("#set-custom-word-button");
        const clearCustomWordButton = $("#clear-custom-word-button");
        
        // Game
        const gameInfoRole = $("#game-info-role");
        const gameInfoWord = $("#game-info-word");
        // NEW: Reveal Role Button
        const revealRoleButton = $("#reveal-role-button");
        const gameStatus = $("#game-status");
        const gameWordList = $("#game-word-list");
        const gamePlayerList = $("#game-player-list");
        const gameLog = $("#game-log");
        const wordInputContainer = $("#word-input-container");
        const wordInput = $("#word-input");
        const submitWordButton = $("#submit-word-button");
        const gameIdDisplay = $("#game-id-display");
        const gameThemeDisplay = $("#game-theme-display"); // NEW: Theme display

        // Modals
        const votingModal = $("#voting-modal");
        const votingPlayerButtons = $("#voting-player-buttons");
        const gameOverModal = $("#game-over-modal");
        const gameOverWinner = $("#game-over-winner");
        const gameOverSecretWord = $("#game-over-secret-word");
        const gameOverInfiltrados = $("#game-over-infiltrados");
        const leaveGameButton = $("#leave-game-button");
        const playAgainButton = $("#play-again-button");

        // --- Secret Word List ---
        const SECRET_WORDS = [
            "Hospital", "School", "Restaurant", "Airport", "Museum", "Beach",
            "Mountain", "Forest", "Office", "Supermarket", "Pharmacy", "Library",
            "Park", "Zoo", "Aquarium", "Cinema", "Theater", "Gym", "Stadium",
            "Farm", "Factory", "Police Station", "Fire Station", "Post Office"
        ];

        // NEW: Player Symbols
        const PLAYER_SYMBOLS = ["üëë", "üöÄ", "‚≠ê", "ü§ñ", "ü¶ä", "ü¶Ñ", "üçï", "‚öΩ", "üé®", "üé∏", "üí°", "üìö", "üß≠", "üß™", "üîë", "üõ°Ô∏è"];

        // --- Helper function for correct Firestore path ---
        function getGameDocRef(gameId) {
            // This constructs the path required by the security rules:
            // /artifacts/{appId}/public/data/games/{gameId}
            return doc(db, "artifacts", appId, "public", "data", "games", gameId);
        }

        // --- Firebase Initialization ---
        async function initFirebase() {
            try {
                // Use injected config if available
                const firebaseConfig = typeof __firebase_config !== 'undefined'
                    ? JSON.parse(__firebase_config)
                    : {
                        // Fallback config (user's original)
                        apiKey: "AIzaSyAG6v0TT9miam83wXOB4aqdqD6qbc5GhPo",
                        authDomain: "infiltrados-game.firebaseapp.com",
                        projectId: "infiltrados-game",
                        storageBucket: "infiltrados-game.firebasestorage.app",
                        messagingSenderId: "742547669169",
                        appId: "1:742547669169:web:68ee3277c5fb077647a290"
                    };
                
                if (!firebaseConfig.apiKey) {
                    showError("Firebase config is missing. App cannot start.");
                    return;
                }

                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                setLogLevel('debug'); // Enable verbose logging for Firestore

                // --- Auth Handling ---
                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        currentUserId = user.uid;
                        console.log("User signed in:", currentUserId);
                        loginSection.classList.add("hidden");
                        lobbySection.classList.remove("hidden");
                    } else {
                        // No user, try to sign in
                        try {
                            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                                await signInWithCustomToken(auth, __initial_auth_token);
                            } else {
                                // Fallback to anonymous if token isn't present
                                await signInAnonymously(auth);
                            }
                        } catch (authError) {
                            console.error("Sign-in failed:", authError);
                            showError("Failed to connect. Please refresh.");
                        }
                    }
                });

            } catch (error) {
                console.error("Error initializing Firebase:", error);
                showError("Fatal Error: Could not initialize app. Check console.");
            }
        }

        // --- UI State Management ---
        function showSection(section) {
            [loginSection, lobbySection, gameSection].forEach(s => s.classList.add("hidden"));
            if (section === "login") loginSection.classList.remove("hidden");
            if (section === "lobby") lobbySection.classList.remove("hidden");
            if (section === "game") gameSection.classList.remove("hidden");
        }

        function showError(message) {
            // In a real app, use a modal. For now, console.
            console.error("ERROR:", message);
            gameStatus.textContent = `Error: ${message}`;
            gameStatus.classList.add("text-red-600");
        }

        // --- Game Logic ---

        // Generate a random 6-char game ID
        function generateGameId() {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }

        function handleUsername() {
            loginError.textContent = ""; // Clear previous error
            const username = usernameInput.value.trim();
            if (username.length >= 2) {
                currentUsername = username;
                usernameInput.disabled = true;
                setUsernameButton.textContent = "Welcome!";
                setUsernameButton.disabled = true;
                // Now that we have a username, try init Firebase
                initFirebase();
            } else {
                loginError.textContent = "Please enter a name (min 2 chars)."; // <-- Better error
            }
        }

        async function createGame() {
            if (!currentUserId) return showError("Not authenticated.");

            const gameId = generateGameId();
            currentGameId = gameId;
            isHost = true;

            const settings = {
                totalPlayers: parseInt(totalPlayersSelect.value),
                infiltradosCount: parseInt(infiltradosSelect.value),
                roundsBeforeVote: parseInt(roundsBeforeVoteSelect.value),
            };

            const gameDoc = {
                gameId: gameId,
                hostId: currentUserId,
                state: "lobby", // lobby, word_round, voting, game_over
                settings: settings,
                players: {
                    [currentUserId]: {
                        name: currentUsername,
                        isAlive: true,
                        role: null,
                        vote: null,
                        symbol: PLAYER_SYMBOLS[0] // Host gets the first symbol
                    }
                },
                secretWord: "",
                customWord: "", // NEW: Field for custom word
                customTheme: "", // NEW: Field for custom theme
                theme: "", // NEW: Field for the *actual* game theme
                turn: null, // playerId of current speaker
                round: 1, // Current word round (1, 2, 3...)
                gameTurn: 1, // Current vote cycle (1, 2, ...)
                words: [], // { player: playerId, name: string, word: string, round: int }
                log: [`Game created by ${currentUsername}`],
                winner: null
            };

            try {
                // Use the correct Firestore path
                const gameRef = getGameDocRef(gameId); // <-- FIX
                await setDoc(gameRef, gameDoc);
                console.log("Game created with ID:", gameId);
                await subscribeToGame(gameId);
            } catch (error) {
                console.error("Error creating game:", error);
                showError("Could not create game.");
            }
        }

        async function joinGame() {
            if (!currentUserId) return showError("Not authenticated.");

            const gameId = gameIdInput.value.trim().toUpperCase();
            if (!gameId) return showError("Please enter a Game ID.");

            const gameRef = getGameDocRef(gameId); // <-- FIX
            const gameSnap = await getDoc(gameRef);

            if (!gameSnap.exists()) {
                return showError("Game not found.");
            }

            const gameData = gameSnap.data();
            
            if (gameData.state !== "lobby") {
                return showError("Game has already started.");
            }

            if (Object.keys(gameData.players).length >= gameData.settings.totalPlayers) {
                return showError("Game is full.");
            }
            
            if (gameData.players[currentUserId]) {
                 // Player is already in, just subscribe
                 console.log("Rejoining lobby...");
            } else {
                // Add new player to the game
                // NEW: Assign a symbol
                const existingSymbols = Object.values(gameData.players).map(p => p.symbol);
                const availableSymbols = PLAYER_SYMBOLS.filter(s => !existingSymbols.includes(s));
                const newSymbol = availableSymbols.length > 0 ? availableSymbols[0] : "‚ùî"; // Pick first available

                const playerKey = `players.${currentUserId}`;
                const newPlayer = {
                    name: currentUsername,
                    isAlive: true,
                    role: null,
                    vote: null,
                    symbol: newSymbol
                };
                
                try {
                    await updateDoc(gameRef, { // gameRef is already correct
                        [playerKey]: newPlayer,
                        log: arrayUnion(`${currentUsername} joined the lobby.`)
                    });
                    console.log("Joined game:", gameId);
                } catch (error) {
                    console.error("Error joining game:", error);
                    return showError("Could not join game.");
                }
            }

            currentGameId = gameId;
            isHost = (gameData.hostId === currentUserId);
            await subscribeToGame(gameId);
        }

        async function subscribeToGame(gameId) {
            if (gameUnsubscribe) {
                gameUnsubscribe();
            }
            
            const gameRef = getGameDocRef(gameId); // <-- FIX
            gameUnsubscribe = onSnapshot(gameRef, (docSnap) => {
                if (!docSnap.exists()) {
                    showError("Game not found or was deleted.");
                    leaveGame();
                    return;
                }

                const gameData = docSnap.data();
                localGameData = gameData; // Cache game data
                updateUI(gameData);

                // --- Host-Only Logic ---
                // This logic runs on the host's client to manage game state transitions.
                if (isHost) {
                    if (gameData.state === "voting" && didAllAlivePlayersVote(gameData)) {
                        // All votes are in, tally them!
                        tallyVotes(gameData);
                    }
                    // Check for word round -> voting transition
                    if (gameData.state === "word_round" && shouldRoundEnd(gameData)) {
                        startVoting(gameData);
                    }
                }

            }, (error) => {
                console.error("Snapshot error:", error);
                showError("Connection to game lost.");
            });
        }

        function leaveGame() {
            if (gameUnsubscribe) {
                gameUnsubscribe();
                gameUnsubscribe = null;
            }
            currentGameId = null;
            isHost = false;
            localGameData = {};
            isRoleVisible = false; // NEW: Reset role visibility
            showSection("lobby");
            lobbyGameIdDisplay.textContent = "";
            lobbyPlayerList.innerHTML = "";
            gameIdInput.value = "";
            customWordContainer.classList.add("hidden"); // Hide custom word box
        }

        async function startGame() {
            if (!isHost || !currentGameId) return;

            const gameData = localGameData;
            const playerIds = Object.keys(gameData.players);

            // Check if player count matches setting
            if (playerIds.length !== gameData.settings.totalPlayers) {
                return showError(`Waiting for ${gameData.settings.totalPlayers} players. Currently have ${playerIds.length}.`);
            }
            
            // --- Assign Roles ---
            const { infiltradosCount } = gameData.settings;
            const newPlayers = { ...gameData.players };
            const shuffledPlayerIds = playerIds.sort(() => 0.5 - Math.random());
            
            const infiltradoIds = [];
            
            for (let i = 0; i < shuffledPlayerIds.length; i++) {
                const id = shuffledPlayerIds[i];
                if (i < infiltradosCount) {
                    newPlayers[id].role = "Infiltrado";
                    infiltradoIds.push(newPlayers[id].name); // For the log
                } else {
                    newPlayers[id].role = "Regular";
                }
            }

            // --- Pick Word & Start Player ---
            // NEW: Use custom word/theme if available
            const customWord = gameData.customWord;
            const customTheme = gameData.customTheme;
            
            const secretWord = customWord || SECRET_WORDS[Math.floor(Math.random() * SECRET_WORDS.length)];
            const theme = customWord ? (customTheme || "General") : "Location/Place"; // Set theme logic
            
            // NEW LOGIC: Pick a random *Regular* player to start
            const regularPlayerIds = Object.keys(newPlayers).filter(id => newPlayers[id].role === "Regular");
            
            let startPlayerId;
            if (regularPlayerIds.length > 0) {
                startPlayerId = regularPlayerIds[Math.floor(Math.random() * regularPlayerIds.length)];
            } else {
                // Fallback: This should only happen if infiltrados >= total players, but as a safety...
                console.warn("No regular players found! Starting with a random player.");
                startPlayerId = shuffledPlayerIds[Math.floor(Math.random() * shuffledPlayerIds.length)];
            }

            // --- Update Game Doc ---
            try {
                const gameRef = getGameDocRef(currentGameId); // <-- FIX
                await updateDoc(gameRef, {
                    state: "word_round",
                    players: newPlayers,
                    secretWord: secretWord,
                    theme: theme, // Set the game theme
                    customWord: "", // Clear custom word after use
                    customTheme: "", // Clear custom theme after use
                    turn: startPlayerId,
                    round: 1,
                    gameTurn: 1,
                    words: [],
                    log: arrayUnion(`Game started! Theme: ${theme}. Roles assigned.`)
                });
            } catch (error) {
                console.error("Error starting game:", error);
                showError("Could not start game.");
            }
        }
        
        // --- In-Game Actions ---

        async function submitWord() {
            const word = wordInput.value.trim();
            if (word.length < 2 || word.includes(" ")) {
                return showError("Please enter a single, valid word.");
            }
            
            if (localGameData.turn !== currentUserId) {
                return showError("It's not your turn!");
            }

            const { players, round, settings, gameTurn } = localGameData;
            const totalAlive = Object.values(players).filter(p => p.isAlive).length;
            const wordsThisRound = localGameData.words.filter(w => w.gameTurn === gameTurn && w.round === round).length;

            const nextPlayer = findNextAlivePlayer(currentUserId);
            let nextRound = round;
            let nextState = "word_round";
            let nextTurn = nextPlayer;
            
            // Check if this word is the last word of the round
            if (wordsThisRound + 1 === totalAlive) {
                nextRound = round + 1;
                // Start next round with the same player who started this one (or first alive)
                nextTurn = findNextAlivePlayer(nextPlayer, true, localGameData.turn); 
            }

            try {
                // This update is NOT the one that triggers voting.
                // The host client will see this update and trigger voting if needed.
                const gameRef = getGameDocRef(currentGameId); // <-- FIX
                await updateDoc(gameRef, {
                    state: nextState,
                    turn: nextTurn,
                    round: nextRound,
                    words: arrayUnion({
                        player: currentUserId,
                        name: players[currentUserId].name,
                        word: word,
                        round: round,
                        gameTurn: gameTurn
                    })
                });
                wordInput.value = "";
            } catch (error) {
                console.error("Error submitting word:", error);
                showError("Could not submit word.");
            }
        }
        
        // Host-only check
        function shouldRoundEnd(gameData) {
            const { players, round, settings, gameTurn, words } = gameData;
            
            // Are we on a voting round? (e.g., Round 2, 4, 6)
            if (round > 1 && (round - 1) % settings.roundsBeforeVote === 0) {
                 const totalAlive = Object.values(players).filter(p => p.isAlive).length;
                 // Have all players spoken in the *previous* round?
                 // (e.g., we are on Round 3, but this check triggers *after* Round 2 ends)
                 // This means `round` is now 3, `round-1` is 2.
                 const wordsInLastRound = words.filter(w => w.gameTurn === gameTurn && w.round === (round - 1)).length;
                 
                 if (wordsInLastRound === totalAlive) {
                     // Yes, the voting round is complete. Time to vote.
                     return true;
                 }
            }
            return false;
        }

        // Host-only action
        async function startVoting(gameData) {
            // Reset all player votes to null
            const playerUpdates = {};
            Object.keys(gameData.players).forEach(id => {
                if (gameData.players[id].isAlive) {
                    playerUpdates[`players.${id}.vote`] = null;
                }
            });
            
            try {
                const gameRef = getGameDocRef(currentGameId); // <-- FIX
                await updateDoc(gameRef, {
                    ...playerUpdates,
                    state: "voting",
                    turn: null, // No one's turn to speak
                    log: arrayUnion(`--- Time to Vote (Turn ${gameData.gameTurn}) ---`)
                });
            } catch (error) {
                console.error("Error starting vote:", error);
            }
        }

        async function submitVote(votedPlayerId) {
            if (localGameData.state !== "voting" || !localGameData.players[currentUserId].isAlive) {
                return showError("You can't vote right now.");
            }
            
            // Optimistic UI update
            votingModal.classList.add("hidden");
            
            try {
                const gameRef = getGameDocRef(currentGameId); // <-- FIX
                await updateDoc(gameRef, {
                    [`players.${currentUserId}.vote`]: votedPlayerId
                });
            } catch (error) {
                console.error("Error submitting vote:", error);
            }
        }

        // Host-only check
        function didAllAlivePlayersVote(gameData) {
            return Object.values(gameData.players).every(p => !p.isAlive || p.vote !== null);
        }

        // Host-only action
        async function tallyVotes(gameData) {
            const votes = {};
            let tiedPlayers = [];
            let maxVotes = 0;
            
            // Count votes
            Object.values(gameData.players).forEach(p => {
                if (p.isAlive && p.vote) {
                    votes[p.vote] = (votes[p.vote] || 0) + 1;
                }
            });

            // Find highest vote count
            for (const playerId in votes) {
                if (votes[playerId] > maxVotes) {
                    maxVotes = votes[playerId];
                }
            }

            // Find all players with that count
            for (const playerId in votes) {
                if (votes[playerId] === maxVotes) {
                    tiedPlayers.push(playerId);
                }
            }
            
            let eliminatedPlayerId;
            let logMessage;

            if (tiedPlayers.length === 0) {
                // This can happen if only one person is alive, but win check should catch it
                // Or if no one votes? For simplicity, we'll just pick a random alive player
                console.warn("No votes cast? Defaulting to random elim.");
                const alivePlayers = Object.keys(gameData.players).filter(id => gameData.players[id].isAlive);
                eliminatedPlayerId = alivePlayers[Math.floor(Math.random() * alivePlayers.length)];
                logMessage = "No votes were cast! By random choice,";
                
            } else if (tiedPlayers.length === 1) {
                // Clear winner
                eliminatedPlayerId = tiedPlayers[0];
                logMessage = "The votes are in!";
            } else {
                // Tie-breaker
                eliminatedPlayerId = tiedPlayers[Math.floor(Math.random() * tiedPlayers.length)];
                logMessage = `A tie! By random choice,`;
            }

            const eliminatedPlayer = gameData.players[eliminatedPlayerId];
            logMessage += ` ${eliminatedPlayer.name} is eliminated.`;
            const revealMessage = `${eliminatedPlayer.name} was... an ${eliminatedPlayer.role}!`;

            // --- Check Win Conditions ---
            let regularsAlive = 0;
            let infiltradosAlive = 0;
            
            Object.values(gameData.players).forEach(p => {
                if (p.isAlive) {
                    if (p.id === eliminatedPlayerId) return; // Don't count them
                    if (p.role === "Regular") regularsAlive++;
                    if (p.role === "Infiltrado") infiltradosAlive++;
                }
            });
            // Final count after this elimination
            if (eliminatedPlayer.role === "Regular") regularsAlive--;
            if (eliminatedPlayer.role === "Infiltrado") infiltradosAlive--;

            // We need the counts *after* this player is removed
            const finalPlayerCounts = { ...gameData.players };
            finalPlayerCounts[eliminatedPlayerId].isAlive = false;
            
            let finalRegulars = 0;
            let finalInfiltrados = 0;
            Object.values(finalPlayerCounts).forEach(p => {
                if (p.isAlive) {
                    if (p.role === "Regular") finalRegulars++;
                    if (p.role === "Infiltrado") finalInfiltrados++;
                }
            });
            
            let nextState = "word_round";
            let winner = null;
            
            if (finalInfiltrados === 0) {
                nextState = "game_over";
                winner = "Regulars";
                logMessage = "The last Infiltrado is out!";
            } else if (finalInfiltrados >= finalRegulars) {
                nextState = "game_over";
                winner = "Infiltrados";
                logMessage = "The Infiltrados can no longer be outvoted!";
            }

            // Find next player to start the new round
            const nextTurnPlayer = findNextAlivePlayer(eliminatedPlayerId, false, gameData.turn);

            try {
                const gameRef = getGameDocRef(currentGameId); // <-- FIX
                await updateDoc(gameRef, {
                    [`players.${eliminatedPlayerId}.isAlive`]: false,
                    state: nextState,
                    winner: winner,
                    turn: nextTurnPlayer,
                    gameTurn: gameData.gameTurn + 1,
                    log: arrayUnion(logMessage, revealMessage)
                });

            } catch (error) {
                console.error("Error in tallyVotes:", error);
            }
        }
        
        async function playAgain() {
            if (!isHost) return;
            
            // Reset game to lobby state, keeping players
            const newPlayers = { ...localGameData.players };
            Object.keys(newPlayers).forEach(id => {
                newPlayers[id].isAlive = true;
                newPlayers[id].role = null;
                newPlayers[id].vote = null;
                // Note: Symbols are intentionally kept
            });
            
            try {
                 const gameRef = getGameDocRef(currentGameId); // <-- FIX
                 await updateDoc(gameRef, {
                    state: "lobby",
                    players: newPlayers,
                    secretWord: "",
                    customWord: "", // Clear custom word
                    customTheme: "", // Clear custom theme
                    theme: "", // Clear game theme
                    turn: null,
                    round: 1,
                    gameTurn: 1,
                    words: [],
                    log: ["Host started a new game!"],
                    winner: null
                 });
            } catch(error) {
                console.error("Error playing again:", error);
            }
        }

        // --- NEW: Role Visibility Toggle Function ---
        function updateRoleVisibility() {
            if (isRoleVisible) {
                const myPlayerData = localGameData.players[currentUserId];
                if (!myPlayerData) return;

                gameInfoRole.textContent = `Role: ${myPlayerData.role}`;
                gameInfoRole.className = myPlayerData.role === "Infiltrado" ? "text-lg font-bold text-red-600" : "text-lg font-bold text-green-600";
                
                if (myPlayerData.role === "Regular") {
                    gameInfoWord.textContent = `Word: ${localGameData.secretWord}`;
                } else if (myPlayerData.role === "Infiltrado") {
                    gameInfoWord.textContent = "Blend in! Guess the word.";
                }
                gameInfoWord.classList.remove("hidden");
                revealRoleButton.textContent = "Hide Role";
                revealRoleButton.classList.add("neu-button-pressed");
            } else {
                gameInfoRole.textContent = "Your Role: [Hidden]";
                gameInfoRole.className = "text-lg font-bold text-gray-700";
                gameInfoWord.classList.add("hidden");
                revealRoleButton.textContent = "Show Role";
                revealRoleButton.classList.remove("neu-button-pressed");
            }
        }

        // --- UI Update Function ---
        function updateUI(gameData) {
            // --- Get player data (needed for modals) ---
            const myPlayerData = gameData.players[currentUserId];
            const amIAlive = myPlayerData && myPlayerData.isAlive;

            // --- Lobby Section ---
            if (gameData.state === "lobby") {
                isRoleVisible = false; // Reset role visibility
                showSection("lobby");
                lobbyGameIdDisplay.textContent = `Game ID: ${gameData.gameId}`;
                
                const players = Object.values(gameData.players);
                lobbyPlayerList.innerHTML = players.map(p => 
                    `<li class="neu-outset-sm p-2">${p.symbol} ${p.name}</li>`
                ).join("");
                
                // Host controls
                startGameButton.classList.toggle("hidden", !isHost);
                $$(".host-setting").forEach(el => el.disabled = !isHost);
                if (isHost) {
                    totalPlayersSelect.value = gameData.settings.totalPlayers;
                    infiltradosSelect.value = gameData.settings.infiltradosCount;
                    roundsBeforeVoteSelect.value = gameData.settings.roundsBeforeVote;
                    // NEW: Show custom word container for host
                    customWordContainer.classList.remove("hidden");
                    customWordInput.value = gameData.customWord || "";
                    customThemeInput.value = gameData.customTheme || ""; // NEW: Update theme input
                } else {
                    customWordContainer.classList.add("hidden");
                }
            }
            
            // --- Game Section ---
            if (gameData.state !== "lobby") {
                showSection("game");
                // Hide lobby-specific elements
                customWordContainer.classList.add("hidden");
                
                gameIdDisplay.textContent = `Game ID: ${gameData.gameId}`;
                gameThemeDisplay.textContent = `Theme: ${gameData.theme || "Loading..."}`; // NEW: Display theme

                // My Info - NOW HANDLED BY REVEAL BUTTON
                // We just ensure the button is visible/hidden
                revealRoleButton.classList.toggle("hidden", !myPlayerData);
                updateRoleVisibility(); // NEW: Update visibility on every render

                // Game Status
                let statusText = "";
                if (gameData.state === "word_round") {
                    const turnPlayerName = gameData.players[gameData.turn]?.name || "Someone";
                    statusText = `Round ${gameData.round}: Waiting for ${turnPlayerName} to speak.`;
                } else if (gameData.state === "voting") {
                    statusText = `Time to vote! (Turn ${gameData.gameTurn})`;
                } else if (gameData.state === "game_over") {
                    statusText = `Game Over! ${gameData.winner} win!`;
                }
                gameStatus.textContent = statusText;

                // Word Input
                const isMyTurn = gameData.state === "word_round" && gameData.turn === currentUserId;
                wordInputContainer.classList.toggle("hidden", !isMyTurn || !amIAlive);

                // Word List
                gameWordList.innerHTML = gameData.words.map(w => {
                    const playerSymbol = gameData.players[w.player]?.symbol || "‚ùî";
                    return `<li class="neu-outset-sm p-2">
                        <span class="font-bold text-indigo-600">${playerSymbol} ${w.name} (R${w.round}):</span>
                        <span class="ml-2 text-gray-800">${w.word}</span>
                    </li>`
                }).join("");
                // Auto-scroll word list
                gameWordList.scrollTop = gameWordList.scrollHeight;
                
                // Player List
                gamePlayerList.innerHTML = Object.values(gameData.players).map(p => 
                    `<li class="p-2 rounded-lg ${p.isAlive ? 'neu-outset-sm' : 'neu-inset text-gray-500 line-through'}">
                        ${p.symbol} ${p.name}
                        ${p.isAlive ? '' : ' (Eliminated)'}
                    </li>`
                ).join("");
                
                // Game Log
                gameLog.innerHTML = gameData.log.slice().reverse().map(entry => 
                    `<li class="text-xs text-gray-600">${entry}</li>` // Text size and color updated
                ).join("");
            }
            
            // --- Modals (MOVED OUTSIDE) ---
            
            // Voting Modal
            if (gameData.state === "voting" && amIAlive && myPlayerData.vote === null) {
                votingPlayerButtons.innerHTML = Object.keys(gameData.players)
                    .filter(id => gameData.players[id].isAlive) // Only show alive players
                    .map(id => {
                        const player = gameData.players[id];
                        const isMe = id === currentUserId;
                        const playerSymbol = player.symbol || "‚ùî"; // Get symbol
                        return `<button data-vote-id="${id}" class="vote-button w-full p-3 rounded-lg neu-button neu-outset ${isMe ? 'neu-button-gray opacity-50 cursor-not-allowed' : 'neu-button-red'}">
                            Vote ${playerSymbol} ${player.name} ${isMe ? '(You)' : ''}
                        </button>`;
                    }).join("");
                votingModal.classList.remove("hidden");
            } else {
                votingModal.classList.add("hidden");
            }
            
            // Game Over Modal
            if (gameData.state === "game_over") {
                isRoleVisible = false; // Reset role visibility
                gameOverWinner.textContent = `${gameData.winner} Win!`;
                // NEW: Show theme on game over
                gameOverSecretWord.textContent = `Word: ${gameData.secretWord} (Theme: ${gameData.theme})`;
                
                const infiltradoNames = Object.values(gameData.players)
                    .filter(p => p.role === "Infiltrado")
                    .map(p => `${p.symbol} ${p.name}`) // Add symbol
                    .join(", ");
                gameOverInfiltrados.textContent = `Infiltrados: ${infiltradoNames}`;
                
                playAgainButton.classList.toggle("hidden", !isHost);
                gameOverModal.classList.remove("hidden");
            } else {
                gameOverModal.classList.add("hidden");
            }
        }
        
        // --- Helper Functions ---
        
        function findNextAlivePlayer(startPlayerId, forceSameRound = false, roundStartPlayerId = null) {
            const playerIds = Object.keys(localGameData.players);
            const alivePlayerIds = playerIds.filter(id => localGameData.players[id].isAlive);
            
            // Sort them to ensure consistent turn order
            // This isn't clockwise, but it's deterministic
            alivePlayerIds.sort();
            
            if (forceSameRound && roundStartPlayerId) {
                // This is for starting a new round (e.g., Round 2)
                // We need to find the *first* alive player at or after the round start player
                const roundStartIndex = alivePlayerIds.indexOf(roundStartPlayerId);
                if (roundStartIndex !== -1) {
                    return alivePlayerIds[roundStartIndex];
                }
                // If round start player is dead, fall through to default
            }

            const startIndex = alivePlayerIds.indexOf(startPlayerId);
            
            if (startIndex === -1) {
                // Start player not found (maybe just eliminated), pick first alive
                return alivePlayerIds[0] || null;
            }
            
            const nextIndex = (startIndex + 1) % alivePlayerIds.length;
            return alivePlayerIds[nextIndex];
        }

        // --- Event Listeners ---
        window.addEventListener("load", () => {
            // Start with only login visible
            showSection("login");
            
            setUsernameButton.addEventListener("click", handleUsername);
            usernameInput.addEventListener("keydown", (e) => {
                if (e.key === "Enter") handleUsername();
            });

            createGameButton.addEventListener("click", createGame);
            joinGameButton.addEventListener("click", joinGame);
            startGameButton.addEventListener("click", startGame);

            submitWordButton.addEventListener("click", submitWord);
            wordInput.addEventListener("keydown", (e) => {
                if (e.key === "Enter") submitWord();
            });
            
            // Event delegation for voting buttons
            votingPlayerButtons.addEventListener("click", (e) => {
                const button = e.target.closest(".vote-button");
                if (button && button.dataset.voteId) {
                    if (button.dataset.voteId === currentUserId) return; // Can't vote for self
                    submitVote(button.dataset.voteId);
                }
            });
            
            leaveGameButton.addEventListener("click", leaveGame);
            playAgainButton.addEventListener("click", playAgain);

            // --- NEW: Custom Word Listeners (WITH BUG FIX) ---
            setCustomWordButton.addEventListener("click", async () => {
                if (!isHost || !currentGameId || localGameData.state !== 'lobby') return;
                const word = customWordInput.value.trim();
                const theme = customThemeInput.value.trim(); // NEW: Get theme
                if (word.length < 2 || word.includes(" ")) {
                    showError("Custom word must be a single word, min 2 chars.");
                    return;
                }
                try {
                    const gameRef = getGameDocRef(currentGameId);
                    await updateDoc(gameRef, { customWord: word, customTheme: theme }); // NEW: Set both
                    localGameData.customWord = word; // BUG FIX: Update local cache
                    localGameData.customTheme = theme; // BUG FIX: Update local cache
                } catch (error) {
                    console.error("Error setting custom word:", error);
                }
            });
            
            clearCustomWordButton.addEventListener("click", async () => {
                if (!isHost || !currentGameId || localGameData.state !== 'lobby') return;
                try {
                    const gameRef = getGameDocRef(currentGameId);
                    await updateDoc(gameRef, { customWord: "", customTheme: "" }); // NEW: Clear both
                    localGameData.customWord = ""; // BUG FIX: Update local cache
                    localGameData.customTheme = ""; // BUG FIX: Update local cache
                    customWordInput.value = "";
                    customThemeInput.value = ""; // NEW: Clear theme input
                } catch (error) {
                    console.error("Error clearing custom word:", error);
                }
            });
            
            // --- NEW: Reveal Role Listeners (TOGGLE) ---
            revealRoleButton.addEventListener("click", () => {
                isRoleVisible = !isRoleVisible; // Toggle state
                updateRoleVisibility(); // Update UI
            });


            // Host settings change handlers
            $$(".host-setting").forEach(el => {
                el.addEventListener("change", async (e) => {
                    if (isHost && currentGameId && localGameData.state === 'lobby') {
                        const key = e.target.dataset.setting;
                        const value = parseInt(e.target.value);
                        try {
                            const gameRef = getGameDocRef(currentGameId); // <-- FIX
                            await updateDoc(gameRef, {
                                [`settings.${key}`]: value
                            });
                        } catch (error) {
                            console.error("Error updating setting:", error);
                        }
                    }
                });
            });
        });

    </script>
</head>
<body class="h-full font-sans text-gray-700 bg-gray-100">

    <!-- Login Section -->
    <section id="login-section" class="flex items-center justify-center h-full p-4">
        <div class="neu-outset p-8 rounded-2xl w-full max-w-sm">
            <h1 class="text-3xl font-bold text-gray-800 text-center mb-6">Welcome to Infiltrados</h1>
            <div class="space-y-4">
                <label for="username-input" class="block text-sm font-medium text-gray-600">Enter your name:</label>
                <input type="text" id="username-input" class="w-full p-3 neu-inset neu-input" placeholder="e.g., Player1">
                <button id="set-username-button" class="w-full p-3 rounded-lg neu-button neu-outset text-indigo-600">
                    Join
                </button>
                <p id="login-error" class="text-red-600 text-sm text-center h-4"></p>
            </div>
        </div>
    </section>

    <!-- Lobby Section -->
    <section id="lobby-section" class="hidden h-full p-4 md:p-8 overflow-y-auto">
        <div class="max-w-4xl mx-auto">
            <h1 class="text-3xl font-bold text-gray-800 text-center mb-6">Game Lobby</h1>
            
            <!-- Join/Create -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                <!-- Create Game -->
                <div class="neu-outset p-6 rounded-2xl">
                    <h2 class="text-xl font-semibold text-gray-800 mb-4">Create New Game</h2>
                    <!-- Settings -->
                    <div class="space-y-3 mb-4">
                        <div>
                            <label for="total-players-select" class="block text-sm font-medium text-gray-600">Total Players</label>
                            <select id="total-players-select" data-setting="totalPlayers" class="host-setting w-full p-2 neu-inset neu-select mt-1">
                                <option>3</option>
                                <option>4</option>
                                <option>5</option>
                                <option>6</option>
                                <option>7</option>
                                <option selected>8</option>
                                <option>9</option>
                                <option>10</option>
                            </select>
                        </div>
                        <div>
                            <label for="infiltrados-select" class="block text-sm font-medium text-gray-600">Infiltrados</label>
                            <select id="infiltrados-select" data-setting="infiltradosCount" class="host-setting w-full p-2 neu-inset neu-select mt-1">
                                <option>1</option>
                                <option selected>2</option>
                                <option>3</option>
                            </select>
                        </div>
                        <div>
                            <label for="rounds-before-vote-select" class="block text-sm font-medium text-gray-600">Rounds Before Vote</label>
                            <select id="rounds-before-vote-select" data-setting="roundsBeforeVote" class="host-setting w-full p-2 neu-inset neu-select mt-1">
                                <option>1</option>
                                <option selected>2</option>
                                <option>3</option>
                            </select>
                        </div>
                    </div>
                    <button id="create-game-button" class="w-full p-3 rounded-lg neu-button neu-outset text-indigo-600">
                        Create Game
                    </button>
                </div>
                
                <!-- Join Game -->
                <div class="neu-outset p-6 rounded-2xl">
                    <h2 class="text-xl font-semibold text-gray-800 mb-4">Join Game</h2>
                    <label for="game-id-input" class="block text-sm font-medium text-gray-600">Enter Game ID:</label>
                    <input type="text" id="game-id-input" class="w-full p-3 mt-1 neu-inset neu-input uppercase" placeholder="ABCXYZ">
                    <button id="join-game-button" class="w-full p-3 mt-4 rounded-lg neu-button neu-outset neu-button-green">
                        Join Game
                    </button>
                </div>
            </div>
            
            <!-- Current Lobby -->
            <div class="neu-outset p-6 rounded-2xl">
                <h2 class="text-2xl font-semibold text-gray-800 mb-4">Waiting Room</h2>
                <h3 id="lobby-game-id" class="text-xl text-indigo-500 font-mono mb-4"></h3>

                <!-- NEW: Custom Word Input (Host Only) -->
                <div id="custom-word-container" class="hidden mb-4 p-4 neu-inset rounded-lg space-y-2">
                    <div>
                        <label for="custom-word-input" class="block text-sm font-medium text-gray-600">Custom Secret Word (Host Only)</label>
                        <input type="text" id="custom-word-input" class="w-full p-2 neu-inset neu-input" placeholder="Leave blank for random">
                    </div>
                    <div>
                        <label for="custom-theme-input" class="block text-sm font-medium text-gray-600">Theme (Optional)</label>
                        <input type="text" id="custom-theme-input" class="w-full p-2 neu-inset neu-input" placeholder="e.g., Football Players">
                    </div>
                    <div class="flex gap-2 pt-2">
                        <button id="set-custom-word-button" class="p-2 neu-button neu-outset-sm rounded-lg neu-button-green">Set</button>
                        <button id="clear-custom-word-button" class_name="p-2 neu-button neu-outset-sm rounded-lg neu-button-gray">Clear</button>
                    </div>
                </div>

                <h4 class="text-lg text-gray-800 mb-2">Players:</h4>
                <ul id="lobby-player-list" class="space-y-2 mb-4">
                    <!-- Player list injected by JS -->
                </ul>
                <button id="start-game-button" class="w-full p-3 rounded-lg neu-button neu-outset neu-button-red hidden">
                    Start Game (Host Only)
                </button>
            </div>
            
        </div>
    </section>

    <!-- Game Section -->
    <section id="game-section" class="hidden h-full flex flex-col p-4 md:p-8">
        <div class="flex-shrink-0 mb-4">
            <!-- Top Bar -->
            <div class="neu-outset flex justify-between items-center p-4 rounded-2xl">
                <div>
                    <h1 class="text-2xl font-bold text-gray-800">Infiltrados</h1>
                    <div id="game-id-display" class="text-sm font-mono text-indigo-500"></div>
                    <div id="game-theme-display" class="text-md font-semibold text-gray-700"></div> <!-- NEW: Theme Display -->
                </div>
                <div class="text-right">
                    <!-- UPDATED: Role display is now hidden by default -->
                    <div id="game-info-role" class="text-lg font-bold text-gray-700">Your Role: [Hidden]</div>
                    <div id="game-info-word" class="text-sm text-gray-600 hidden"></div>
                    <!-- UPDATED: Reveal Role Button (Toggle) -->
                    <button id="reveal-role-button" class="mt-1 p-2 neu-button neu-outset-sm rounded-lg text-sm neu-button-blue">
                        Show Role
                    </button>
                </div>
                <button id="leave-game-button" class="p-2 neu-button neu-outset-sm rounded-lg text-sm neu-button-gray">Leave Game</button>
            </div>
            <!-- Status Bar -->
            <div id="game-status" class="text-center text-xl font-semibold text-yellow-600 p-4">
                Loading game...
            </div>
        </div>

        <!-- Main Game Area -->
        <div class="flex-grow grid grid-cols-1 lg:grid-cols-4 gap-6 min-h-0">
            
            <!-- Players -->
            <div class="neu-outset p-4 rounded-2xl">
                <h3 class="text-lg font-semibold text-gray-800 mb-3 border-b border-gray-300 pb-2">Players</h3>
                <ul id="game-player-list" class="space-y-2">
                    <!-- Player list injected by JS -->
                </ul>
            </div>
            
            <!-- Words -->
            <div class="neu-outset p-4 rounded-2xl lg:col-span-2 flex flex-col">
                <h3 class="text-lg font-semibold text-gray-800 mb-3 border-b border-gray-300 pb-2">Word List</h3>
                <ul id="game-word-list" class="flex-grow space-y-2 overflow-y-auto h-64 md:h-auto p-1">
                    <!-- Word list injected by JS -->
                </ul>
                <!-- Word Input -->
                <div id="word-input-container" class="mt-4 flex gap-2 hidden">
                    <input type="text" id="word-input" class="flex-grow p-3 neu-inset neu-input" placeholder="Your word...">
                    <button id="submit-word-button" class="p-3 rounded-lg neu-button neu-outset text-indigo-600">
                        Submit
                    </button>
                </div>
            </div>
            
            <!-- Log -->
            <div class="neu-outset p-4 rounded-2xl">
                <h3 class="text-lg font-semibold text-gray-800 mb-3 border-b border-gray-300 pb-2">Game Log</h3>
                <ul id="game-log" class="space-y-1 overflow-y-auto h-64 md:h-auto max-h-72"> <!-- Height Reduced -->
                    <!-- Log entries injected by JS -->
                </ul>
            </div>
            
        </div>
    </section>
    
    <!-- Voting Modal -->
    <div id="voting-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
        <div class="neu-outset p-8 rounded-2xl shadow-xl w-full max-w-md">
            <h2 class="text-3xl font-bold text-gray-800 text-center mb-6">Vote to Eliminate!</h2>
            <div id="voting-player-buttons" class="space-y-3">
                <!-- Voting buttons injected by JS -->
            </div>
        </div>
    </div>
    
    <!-- Game Over Modal -->
    <div id="game-over-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
        <div class="neu-outset p-8 rounded-2xl shadow-xl w-full max-w-md text-center">
            <h2 id="game-over-winner" class="text-4xl font-bold text-yellow-600 mb-4"></h2>
            <p id="game-over-secret-word" class="text-xl text-gray-800 mb-2"></p>
            <p id="game-over-infiltrados" class="text-lg text-red-600 mb-8"></p>
            
            <button id="play-again-button" class="w-full p-3 mb-3 rounded-lg neu-button neu-outset text-indigo-600 hidden">
                Play Again (Host)
            </button>
            <p class="text-sm text-gray-600">Wait for the host to start a new game.</p>
        </div>
    </div>

</body>
</html>
